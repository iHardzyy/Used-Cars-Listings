<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[Alex King]Super Mario Bros</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #5C94FC;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
        }

        #gameContainer {
            background: #000;
            border: 4px solid #fff;
            position: relative;
        }

        #gameCanvas {
            display: block;
            background: #5C94FC;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 16px;
            z-index: 10;
            pointer-events: none;
        }

        .controls {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-size: 12px;
            text-align: right;
            z-index: 10;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="ui">
            <div>SCORE: <span id="score">000000</span></div>
            <div>COINS: <span id="coins">00</span></div>
            <div>WORLD: <span id="world">1-1</span></div>
            <div>LIVES: <span id="lives">3</span></div>
            <div>TIME: <span id="timer">400</span></div>
        </div>
        <div class="controls">
            <div>ARROW KEYS / WASD: Move</div>
            <div>SPACE / UP: Jump</div>
            <div>SHIFT: Run</div>
            <div>F: Fireball (Fire Mario)</div>
        </div>
    </div>

    <script>
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.width = this.canvas.width;
                this.height = this.canvas.height;
                
                this.state = 'worldmap'; // 'worldmap', 'playing', 'gameover'
                this.camera = { x: 0, y: 0 };
                
                this.score = 0;
                this.coins = 0;
                this.lives = 3;
                this.currentWorld = 1;
                this.currentLevel = 1;
                this.timer = 400;
                
                this.keys = {};
                this.lastTime = 0;
                
                this.worldMap = new WorldMap(this);
                this.level = null;
                
                this.setupEventListeners();
                
                requestAnimationFrame((time) => this.gameLoop(time));
            }

            setupEventListeners() {
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
                
                this.canvas.addEventListener('click', (e) => {
                    if (this.state === 'worldmap') {
                        const rect = this.canvas.getBoundingClientRect();
                        const mouseX = e.clientX - rect.left;
                        const mouseY = e.clientY - rect.top;
                        this.worldMap.handleClick(mouseX, mouseY);
                    }
                });
                
                this.canvas.addEventListener('mousemove', (e) => {
                    if (this.state === 'worldmap') {
                        const rect = this.canvas.getBoundingClientRect();
                        const mouseX = e.clientX - rect.left;
                        const mouseY = e.clientY - rect.top;
                        this.worldMap.handleMouseMove(mouseX, mouseY);
                    }
                });
            }
            
            gameLoop(currentTime) {
                const deltaTime = Math.min((currentTime - this.lastTime) / 1000, 0.016);
                this.lastTime = currentTime;
                
                this.update(deltaTime);
                this.render();
                
                requestAnimationFrame((time) => this.gameLoop(time));
            }
            
            update(deltaTime) {
                if (this.state === 'worldmap') {
                    this.worldMap.update(deltaTime);
                } else if (this.state === 'playing') {
                    this.level.update(deltaTime);
                    this.timer -= deltaTime;
                    if (this.timer <= 0) {
                        this.loseLife();
                    }
                }
                
                this.updateUI();
            }
            
            render() {
                this.ctx.clearRect(0, 0, this.width, this.height);
                
                if (this.state === 'worldmap') {
                    this.worldMap.render(this.ctx);
                } else if (this.state === 'playing') {
                    this.level.render(this.ctx, this.camera);
                } else if (this.state === 'gameover') {
                    this.renderGameOver();
                }
            }
            
            startLevel(world, level) {
                this.currentWorld = world;
                this.currentLevel = level;
                this.state = 'playing';
                this.timer = 400;
                this.level = new Level(this, world, level);
                this.camera.x = 0;
                this.camera.y = 0;
            }
            
            completeLevel() {
                this.score += Math.floor(this.timer) * 50;
                this.worldMap.completeLevel(this.currentWorld, this.currentLevel);
                this.state = 'worldmap';
                this.level = null;
            }
            
            loseLife() {
                this.lives--;
                if (this.lives <= 0) {
                    this.state = 'gameover';
                } else {
                    this.startLevel(this.currentWorld, this.currentLevel);
                }
            }
            
            addScore(points) {
                this.score += points;
            }
            
            addCoin() {
                this.coins++;
                this.addScore(200);
                if (this.coins >= 100) {
                    this.coins -= 100;
                    this.lives++;
                }
            }
            
            updateUI() {
                document.getElementById('score').textContent = this.score.toString().padStart(6, '0');
                document.getElementById('coins').textContent = this.coins.toString().padStart(2, '0');
                document.getElementById('world').textContent = `${this.currentWorld}-${this.currentLevel}`;
                document.getElementById('lives').textContent = this.lives.toString();
                document.getElementById('timer').textContent = Math.max(0, Math.floor(this.timer)).toString();
            }
            
            renderGameOver() {
                this.ctx.fillStyle = 'black';
                this.ctx.fillRect(0, 0, this.width, this.height);
                this.ctx.fillStyle = 'white';
                this.ctx.font = '48px Courier New';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('GAME OVER', this.width / 2, this.height / 2);
                this.ctx.font = '24px Courier New';
                this.ctx.fillText('Press F5 to restart', this.width / 2, this.height / 2 + 60);
            }
        }

        class WorldMap {
            constructor(game) {
                this.game = game;
                this.playerX = 100;
                this.playerY = 300;
                this.selectedLevel = 1;
                this.selectedWorld = 1;
                this.completedLevels = new Set();
                this.hoveredLevel = -1;
                this.hoveredWorld = -1;
                this.currentWorldIndex = 0;
                this.worlds = [];
                this.initializeWorlds();
            }

            initializeWorlds() {
                this.worlds = [
                    {
                        id: 1,
                        name: "Grass Land",
                        x: 50,
                        y: 200,
                        levels: [
                            { x: 100, y: 300, world: 1, level: 1, name: "World 1-1" },
                            { x: 200, y: 250, world: 1, level: 2, name: "World 1-2" },
                            { x: 300, y: 200, world: 1, level: 3, name: "World 1-3" },
                            { x: 400, y: 250, world: 1, level: 4, name: "World 1-4" },
                            { x: 500, y: 300, world: 1, level: 5, name: "World 1-5" },
                            { x: 600, y: 200, world: 1, level: 6, name: "World 1-6" }
                        ]
                    },
                    {
                        id: 2,
                        name: "Desert Hill",
                        x: 50,
                        y: 400,
                        levels: [
                            { x: 100, y: 450, world: 2, level: 1, name: "World 2-1" },
                            { x: 200, y: 400, world: 2, level: 2, name: "World 2-2" },
                            { x: 300, y: 350, world: 2, level: 3, name: "World 2-3" },
                            { x: 400, y: 400, world: 2, level: 4, name: "World 2-4" },
                            { x: 500, y: 450, world: 2, level: 5, name: "World 2-5" },
                            { x: 600, y: 350, world: 2, level: 6, name: "World 2-6" }
                        ]
                    }
                ];
            }

            handleClick(mouseX, mouseY) {
                this.worlds.forEach((world, worldIndex) => {
                    const distance = Math.sqrt((mouseX - world.x) ** 2 + (mouseY - world.y) ** 2);
                    if (distance <= 30) {
                        this.currentWorldIndex = worldIndex;
                        this.selectedWorld = world.id;
                        this.selectedLevel = 1;
                    }
                });

                const currentWorld = this.worlds[this.currentWorldIndex];
                if (!currentWorld || !currentWorld.levels) return;

                currentWorld.levels.forEach((level, index) => {
                    const distance = Math.sqrt((mouseX - level.x) ** 2 + (mouseY - level.y) ** 2);
                    if (distance <= 25) {
                        const levelNum = index + 1;
                        if (levelNum === 1 || this.completedLevels.has(`${level.world}-${levelNum - 1}`)) {
                            this.selectedLevel = levelNum;
                            this.selectedWorld = level.world;
                            this.game.startLevel(level.world, level.level);
                        }
                    }
                });
            }

            handleMouseMove(mouseX, mouseY) {
                this.hoveredLevel = -1;
                this.hoveredWorld = -1;
                
                this.worlds.forEach((world, worldIndex) => {
                    const distance = Math.sqrt((mouseX - world.x) ** 2 + (mouseY - world.y) ** 2);
                    if (distance <= 30) {
                        this.hoveredWorld = worldIndex;
                        this.game.canvas.style.cursor = 'pointer';
                    }
                });

                const currentWorld = this.worlds[this.currentWorldIndex];
                if (!currentWorld || !currentWorld.levels) return;

                currentWorld.levels.forEach((level, index) => {
                    const distance = Math.sqrt((mouseX - level.x) ** 2 + (mouseY - level.y) ** 2);
                    if (distance <= 25) {
                        this.hoveredLevel = index + 1;
                        this.game.canvas.style.cursor = 'pointer';
                    }
                });

                if (this.hoveredLevel === -1 && this.hoveredWorld === -1) {
                    this.game.canvas.style.cursor = 'default';
                }
            }

            update(deltaTime) {
                const currentWorld = this.worlds[this.currentWorldIndex];
                if (!currentWorld || !currentWorld.levels) return;

                const speed = 100;
                
                // Keyboard navigation
                if ((this.game.keys['ArrowLeft'] || this.game.keys['KeyA']) && this.selectedLevel > 1) {
                    this.selectedLevel--;
                    this.game.keys['ArrowLeft'] = false;
                    this.game.keys['KeyA'] = false;
                }
                if ((this.game.keys['ArrowRight'] || this.game.keys['KeyD']) && this.selectedLevel < currentWorld.levels.length) {
                    this.selectedLevel++;
                    this.game.keys['ArrowRight'] = false;
                    this.game.keys['KeyD'] = false;
                }
                if (this.game.keys['Enter'] || this.game.keys['Space']) {
                    const level = currentWorld.levels[this.selectedLevel - 1];
                    if (level && (this.selectedLevel === 1 || this.completedLevels.has(`${level.world}-${this.selectedLevel - 1}`))) {
                        this.game.startLevel(level.world, level.level);
                    }
                    this.game.keys['Enter'] = false;
                    this.game.keys['Space'] = false;
                }

                const targetLevel = currentWorld.levels[this.selectedLevel - 1];
                if (targetLevel) {
                    const dx = targetLevel.x - this.playerX;
                    const dy = targetLevel.y - this.playerY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist > 2) {
                        this.playerX += (dx / dist) * speed * deltaTime;
                        this.playerY += (dy / dist) * speed * deltaTime;
                    } else {
                        this.playerX = targetLevel.x;
                        this.playerY = targetLevel.y;
                    }
                }
            }
            
            render(ctx) {
                const currentWorld = this.worlds[this.currentWorldIndex];
                if (!currentWorld || !currentWorld.levels) return;
                
                ctx.fillStyle = '#5C94FC';
                ctx.fillRect(0, 0, this.game.width, this.game.height);
                
                ctx.fillStyle = '#228B22';
                ctx.fillRect(0, this.game.height - 100, this.game.width, 100);
                
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 4;
                for (let i = 0; i < currentWorld.levels.length - 1; i++) {
                    const level1 = currentWorld.levels[i];
                    const level2 = currentWorld.levels[i + 1];
                    ctx.beginPath();
                    ctx.moveTo(level1.x, level1.y);
                    ctx.lineTo(level2.x, level2.y);
                    ctx.stroke();
                }
                
                currentWorld.levels.forEach((level, index) => {
                    const levelKey = `${level.world}-${level.level}`;
                    const isCompleted = this.completedLevels.has(levelKey);
                    const isSelected = this.selectedLevel === level.level;
                    const isHovered = this.hoveredLevel === level.level;
                    const isAvailable = level.level === 1 || this.completedLevels.has(`${level.world}-${level.level - 1}`);

                    ctx.fillStyle = 'rgba(0,0,0,0.3)';
                    ctx.beginPath();
                    ctx.arc(level.x + 2, level.y + 2, 22, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = isCompleted ? '#FFD700' : (isAvailable ? '#FFF' : '#666');
                    if (isHovered && isAvailable) {
                        ctx.fillStyle = isCompleted ? '#FFFF00' : '#E0E0E0';
                    }
                    ctx.strokeStyle = isSelected ? '#FF0000' : (isHovered ? '#FF4500' : '#000');
                    ctx.lineWidth = isSelected ? 4 : (isHovered ? 3 : 2);
                    
                    ctx.beginPath();
                    ctx.arc(level.x, level.y, 22, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 18px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${level.level}`, level.x, level.y + 6);
                    
                    if (isHovered) {
                        ctx.fillStyle = 'rgba(0,0,0,0.8)';
                        ctx.fillRect(level.x - 40, level.y - 50, 80, 20);
                        ctx.fillStyle = 'white';
                        ctx.font = '12px Courier New';
                        ctx.fillText(level.name, level.x, level.y - 35);
                    }
                });

                this.renderMario(ctx, this.playerX, this.playerY);
                
                ctx.fillStyle = 'white';
                ctx.font = '18px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('Click on levels to select and start them', this.game.width / 2, 50);
                ctx.font = '14px Courier New';
                ctx.fillText('Use arrow keys or mouse to navigate', this.game.width / 2, 75);
            }
            
            renderMario(ctx, x, y) {
                // Detailed Mario sprite for world map
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(x - 8, y - 20, 16, 8);
                ctx.fillRect(x - 6, y - 18, 12, 4);
                
                ctx.fillStyle = '#FFDBAC';
                ctx.fillRect(x - 6, y - 14, 12, 8);
                
                ctx.fillStyle = '#000000';
                ctx.fillRect(x - 4, y - 12, 2, 2);
                ctx.fillRect(x + 2, y - 12, 2, 2);
                
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(x - 1, y - 10, 2, 1);
                
                ctx.fillStyle = '#654321';
                ctx.fillRect(x - 4, y - 9, 8, 2);
                
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(x - 8, y - 6, 16, 8);
                
                ctx.fillStyle = '#0066CC';
                ctx.fillRect(x - 6, y + 2, 12, 6);
                
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(x - 2, y - 4, 1, 1);
                ctx.fillRect(x + 1, y - 4, 1, 1);
                
                ctx.fillStyle = '#FFDBAC';
                ctx.fillRect(x - 10, y - 6, 2, 8);
                ctx.fillRect(x + 8, y - 6, 2, 8);
                
                ctx.fillStyle = '#0066CC';
                ctx.fillRect(x - 4, y + 8, 3, 6);
                ctx.fillRect(x + 1, y + 8, 3, 6);
                
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(x - 5, y + 12, 4, 2);
                ctx.fillRect(x + 1, y + 12, 4, 2);
            }
            
            completeLevel(world, level) {
                this.completedLevels.add(`${world}-${level}`);
            }
        }
        
        class Level {
            constructor(game, world, level) {
                this.game = game;
                this.world = world;
                this.levelNum = level;
                this.width = 3200;
                this.height = 600;
                
                this.player = new Player(this, 100, this.height - 96);
                this.enemies = [];
                this.blocks = [];
                this.powerUps = [];
                this.particles = [];
                this.fireballs = []; // Array for player fireballs
                this.marioIsSmall = true;
                
                this.generateLevel();
                
                this.flagpole = { x: this.width - 100, y: this.height - 200, reached: false, width: 16, height: 168 };
                this.castle = { x: this.width - 250, y: this.height - 164, width: 100, height: 100 };
            }
            
            generateLevel() {
                // Ground
                for (let x = 0; x < this.width; x += 32) {
                    this.blocks.push(new Block(this, x, this.height - 32, 'ground'));
                    this.blocks.push(new Block(this, x, this.height - 64, 'ground'));
                }
                
                // Platforms and enemies for World 1-1
                const blocks = [
                    { x: 320, y: this.height - 200, type: 'question', content: 'coin' },
                    { x: 384, y: this.height - 300, type: 'question', content: 'mushroom' },
                    { x: 416, y: this.height - 300, type: 'brick' },
                    { x: 448, y: this.height - 300, type: 'question', content: 'star' },
                    { x: 512, y: this.height - 200, type: 'question', content: 'coin' },
                ];
                blocks.forEach(b => this.blocks.push(new Block(this, b.x, b.y, b.type, b.content)));

                const enemies = [
                    { x: 500, y: this.height - 96, type: 'goomba' },
                    { x: 750, y: this.height - 96, type: 'goomba' },
                    { x: 1050, y: this.height - 96, type: 'koopa' },
                    { x: 1400, y: this.height - 96, type: 'goomba' },
                    { x: 1450, y: this.height - 96, type: 'goomba' },
                    { x: 1900, y: this.height - 96, type: 'goomba' },
                    { x: 2200, y: this.height - 96, type: 'koopa' },
                ];
                enemies.forEach(e => {
                    if (e.type === 'goomba') this.enemies.push(new Goomba(this, e.x, e.y));
                    if (e.type === 'koopa') this.enemies.push(new Koopa(this, e.x, e.y));
                });
            }

            update(deltaTime) {
                // Update player
                this.player.update(deltaTime, this.game.keys);
                
                // Update enemies
                this.enemies.forEach(enemy => enemy.update(deltaTime));
                
                // Update power-ups
                this.powerUps.forEach(p => p.update(deltaTime));

                // Update fireballs
                this.fireballs.forEach(f => f.update(deltaTime));
                
                // Remove off-screen/dead entities
                this.enemies = this.enemies.filter(e => !e.isDead);
                this.powerUps = this.powerUps.filter(p => !p.isConsumed);
                this.fireballs = this.fireballs.filter(f => !f.isDead);

                // Collision detection
                this.checkCollisions();

                // Check for level completion
                if (this.player.x > this.flagpole.x && !this.flagpole.reached) {
                    this.flagpole.reached = true;
                    this.game.completeLevel();
                }

                // Camera follow player
                this.game.camera.x = this.player.x - this.game.width / 2;
                if (this.game.camera.x < 0) this.game.camera.x = 0;
                if (this.game.camera.x > this.width - this.game.width) {
                    this.game.camera.x = this.width - this.game.width;
                }
            }

            checkCollisions() {
                // Player with Blocks
                this.blocks.forEach(block => {
                    this.player.checkBlockCollision(block);
                    this.enemies.forEach(enemy => enemy.checkBlockCollision(block));
                    this.powerUps.forEach(p => p.checkBlockCollision(block));
                    this.fireballs.forEach(f => f.checkBlockCollision(block));
                });

                // Player with Enemies
                this.enemies.forEach(enemy => {
                    if (this.player.isCollidingWith(enemy)) {
                        if (this.player.velY > 0 && this.player.y + this.player.height <= enemy.y + 10) {
                            this.player.bounce();
                            enemy.stomp();
                            this.game.addScore(100);
                        } else {
                            this.player.hit();
                        }
                    }
                });

                // Player with Power-Ups
                this.powerUps.forEach(p => {
                    if (this.player.isCollidingWith(p)) {
                        p.onCollide(this.player);
                        this.game.addScore(1000);
                    }
                });

                // Fireballs with Enemies
                this.fireballs.forEach(fireball => {
                    this.enemies.forEach(enemy => {
                        if (fireball.isCollidingWith(enemy)) {
                            fireball.die();
                            enemy.stomp(); // Same effect as stomp
                            this.game.addScore(200);
                        }
                    });
                });
            }

            render(ctx, camera) {
                // Background
                ctx.fillStyle = '#5C94FC';
                ctx.fillRect(0, 0, this.game.width, this.game.height);

                // Blocks
                this.blocks.forEach(block => block.render(ctx, camera));

                // Enemies
                this.enemies.forEach(enemy => enemy.render(ctx, camera));
                
                // Power-ups
                this.powerUps.forEach(p => p.render(ctx, camera));

                // Fireballs
                this.fireballs.forEach(f => f.render(ctx, camera));
                
                // Player
                this.player.render(ctx, camera);
                
                // Flagpole
                this.renderFlagpole(ctx, camera);
                this.renderCastle(ctx, camera);
            }

            renderFlagpole(ctx, camera) {
                ctx.fillStyle = '#A0522D';
                ctx.fillRect(this.flagpole.x - camera.x, this.flagpole.y - camera.y, this.flagpole.width, this.flagpole.height);
                ctx.fillStyle = '#FF0000';
                ctx.beginPath();
                ctx.moveTo(this.flagpole.x - camera.x + this.flagpole.width, this.flagpole.y - camera.y);
                ctx.lineTo(this.flagpole.x - camera.x + this.flagpole.width, this.flagpole.y - camera.y + 40);
                ctx.lineTo(this.flagpole.x - camera.x + this.flagpole.width + 30, this.flagpole.y - camera.y + 20);
                ctx.fill();
            }

            renderCastle(ctx, camera) {
                ctx.fillStyle = '#808080';
                ctx.fillRect(this.castle.x - camera.x, this.castle.y - camera.y, this.castle.width, this.castle.height);
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(this.castle.x - camera.x + 40, this.castle.y - camera.y + 20, 20, 20);
            }
        }
        
        class Player {
            constructor(level, x, y) {
                this.level = level;
                this.x = x;
                this.y = y;
                this.width = 32;
                this.height = 32;
                this.velX = 0;
                this.velY = 0;
                this.isGrounded = false;
                this.jumpStrength = -400;
                this.speed = 150;
                this.runSpeed = 250;
                this.isSmall = true;
                this.isStar = false;
                this.starTimer = 0;
            }

            update(deltaTime, keys) {
                // Handle horizontal movement
                this.velX = 0;
                const currentSpeed = keys['ShiftLeft'] ? this.runSpeed : this.speed;
                if (keys['ArrowLeft'] || keys['KeyA']) {
                    this.velX = -currentSpeed;
                }
                if (keys['ArrowRight'] || keys['KeyD']) {
                    this.velX = currentSpeed;
                }

                // Handle jumping
                if ((keys['ArrowUp'] || keys['KeyW'] || keys['Space']) && this.isGrounded) {
                    this.velY = this.jumpStrength;
                    this.isGrounded = false;
                }
                
                // Handle fireball
                if (keys['KeyF'] && !this.isSmall) {
                    this.shootFireball();
                    keys['KeyF'] = false; // Prevent rapid fire
                }

                // Apply gravity
                this.velY += 980 * deltaTime;

                // Update position
                this.x += this.velX * deltaTime;
                this.y += this.velY * deltaTime;

                // Check for star power
                if (this.isStar) {
                    this.starTimer -= deltaTime;
                    if (this.starTimer <= 0) {
                        this.isStar = false;
                    }
                }
            }

            checkBlockCollision(block) {
                if (this.isCollidingWith(block)) {
                    const overlapX = Math.min(this.x + this.width - block.x, block.x + block.width - this.x);
                    const overlapY = Math.min(this.y + this.height - block.y, block.y + block.height - this.y);

                    if (overlapX > overlapY) { // Vertical collision
                        if (this.y < block.y) { // Hitting block from below
                            this.y = block.y - this.height;
                            this.velY = 0;
                            this.isGrounded = true;
                        } else { // Hitting block from above
                            this.y = block.y + block.height;
                            this.velY = 0;
                            block.onHit(this); // Trigger block's onHit method
                        }
                    } else { // Horizontal collision
                        if (this.x < block.x) {
                            this.x = block.x - this.width;
                        } else {
                            this.x = block.x + block.width;
                        }
                        this.velX = 0;
                    }
                }
            }

            isCollidingWith(entity) {
                return this.x < entity.x + entity.width &&
                       this.x + this.width > entity.x &&
                       this.y < entity.y + entity.height &&
                       this.y + this.height > entity.y;
            }
            
            hit() {
                if (this.isStar) return;
                
                if (!this.isSmall) {
                    this.isSmall = true;
                    this.height = 32;
                    this.y += 32; // Adjust position to not sink into ground
                } else {
                    this.level.game.loseLife();
                }
            }
            
            powerUp(type) {
                if (type === 'mushroom') {
                    if (this.isSmall) {
                        this.isSmall = false;
                        this.height = 64;
                        this.y -= 32;
                    }
                } else if (type === 'fireflower') {
                    this.isSmall = false;
                } else if (type === 'star') {
                    this.isStar = true;
                    this.starTimer = 10;
                }
            }
            
            shootFireball() {
                this.level.fireballs.push(new Fireball(this.level, this.x, this.y, this.velX > 0));
            }

            bounce() {
                this.velY = -250;
            }

            render(ctx, camera) {
                // Render Mario
                ctx.fillStyle = 'red';
                if (!this.isSmall) {
                    ctx.fillStyle = 'blue';
                }
                if (this.isStar) {
                    ctx.fillStyle = ['red', 'yellow', 'green', 'blue'][Math.floor(Date.now() / 100) % 4];
                }
                
                ctx.fillRect(this.x - camera.x, this.y - camera.y, this.width, this.height);
            }
        }
        
        class Block {
            constructor(level, x, y, type, content = null) {
                this.level = level;
                this.x = x;
                this.y = y;
                this.width = 32;
                this.height = 32;
                this.type = type; // 'ground', 'brick', 'question'
                this.content = content; // 'coin', 'mushroom', 'star', 'fireflower'
                this.isHit = false;
                this.isDead = false;
            }
            
            onHit(player) {
                if (this.type === 'question' && !this.isHit) {
                    this.isHit = true;
                    this.y -= 5;
                    if (this.content) {
                        this.level.powerUps.push(new PowerUp(this.level, this.x, this.y, this.content));
                        if (this.content === 'coin') {
                            this.level.game.addCoin();
                        }
                    }
                } else if (this.type === 'brick') {
                    if (player.isSmall) {
                        // Play brick hit sound
                    } else {
                        // Break brick
                        this.isDead = true;
                        this.level.particles.push(new Particle(this.level, this.x, this.y, 'brick'));
                    }
                }
            }

            render(ctx, camera) {
                ctx.fillStyle = this.type === 'ground' ? '#8B4513' : (this.type === 'brick' ? '#A0522D' : (this.isHit ? '#A9A9A9' : '#FFD700'));
                ctx.fillRect(this.x - camera.x, this.y - camera.y, this.width, this.height);
                if (this.type === 'question' && !this.isHit) {
                    ctx.fillStyle = 'black';
                    ctx.fillText('?', this.x - camera.x + this.width / 2, this.y - camera.y + this.height / 2 + 5);
                }
            }
        }

        class Enemy {
            constructor(level, x, y) {
                this.level = level;
                this.x = x;
                this.y = y;
                this.width = 32;
                this.height = 32;
                this.velX = -50;
                this.velY = 0;
                this.isDead = false;
            }
            
            update(deltaTime) {
                if (this.isDead) {
                    this.y += this.velY * deltaTime;
                    this.velY += 980 * deltaTime;
                    return;
                }
                this.x += this.velX * deltaTime;
                this.y += this.velY * deltaTime;
                this.velY += 980 * deltaTime;
            }

            checkBlockCollision(block) {
                if (this.x < block.x + block.width && this.x + this.width > block.x && this.y < block.y + block.height && this.y + this.height > block.y) {
                    const overlapX = Math.min(this.x + this.width - block.x, block.x + block.width - this.x);
                    const overlapY = Math.min(this.y + this.height - block.y, block.y + block.height - this.y);
                    
                    if (overlapX > overlapY) {
                        if (this.y < block.y) {
                            this.y = block.y - this.height;
                            this.velY = 0;
                        } else {
                            this.y = block.y + block.height;
                            this.velY = 0;
                        }
                    } else {
                        this.velX *= -1;
                    }
                }
            }

            stomp() {
                this.isDead = true;
                this.velY = -300;
                this.velX = 0;
            }
        }
        
        class Goomba extends Enemy {
            constructor(level, x, y) {
                super(level, x, y);
                this.type = 'goomba';
            }
            
            render(ctx, camera) {
                if (this.isDead) return;
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(this.x - camera.x, this.y - camera.y, this.width, this.height);
            }
        }

        class Koopa extends Enemy {
            constructor(level, x, y) {
                super(level, x, y);
                this.type = 'koopa';
            }

            render(ctx, camera) {
                if (this.isDead) return;
                ctx.fillStyle = '#228B22';
                ctx.fillRect(this.x - camera.x, this.y - camera.y, this.width, this.height);
            }
        }

        class PowerUp {
            constructor(level, x, y, type) {
                this.level = level;
                this.x = x;
                this.y = y;
                this.width = 32;
                this.height = 32;
                this.type = type;
                this.velX = 50;
                this.velY = -200;
                this.isConsumed = false;
            }
            
            update(deltaTime) {
                if (this.isConsumed) return;
                this.x += this.velX * deltaTime;
                this.y += this.velY * deltaTime;
                this.velY += 980 * deltaTime;
            }
            
            onCollide(player) {
                this.isConsumed = true;
                player.powerUp(this.type);
            }
            
            checkBlockCollision(block) {
                if (this.x < block.x + block.width && this.x + this.width > block.x && this.y < block.y + block.height && this.y + this.height > block.y) {
                    const overlapY = Math.min(this.y + this.height - block.y, block.y + block.height - this.y);
                    if (this.y < block.y) {
                        this.y = block.y - this.height;
                        this.velY = 0;
                    } else {
                        this.y = block.y + block.height;
                        this.velY = 0;
                    }
                }
            }

            render(ctx, camera) {
                if (this.isConsumed) return;
                if (this.type === 'mushroom') ctx.fillStyle = 'red';
                if (this.type === 'fireflower') ctx.fillStyle = 'orange';
                if (this.type === 'star') ctx.fillStyle = 'yellow';
                if (this.type === 'coin') {
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(this.x + this.width/2 - camera.x, this.y + this.height/2 - camera.y, this.width/2, 0, Math.PI * 2);
                    ctx.fill();
                    return;
                }
                ctx.fillRect(this.x - camera.x, this.y - camera.y, this.width, this.height);
            }
        }

        class Fireball {
            constructor(level, x, y, directionRight) {
                this.level = level;
                this.x = x;
                this.y = y;
                this.width = 16;
                this.height = 16;
                this.velX = directionRight ? 300 : -300;
                this.velY = -200;
                this.isDead = false;
            }

            update(deltaTime) {
                this.x += this.velX * deltaTime;
                this.y += this.velY * deltaTime;
                this.velY += 980 * deltaTime; // Gravity
                if (this.y > this.level.height) this.isDead = true;
            }

            checkBlockCollision(block) {
                if (this.x < block.x + block.width && this.x + this.width > block.x && this.y < block.y + block.height && this.y + this.height > block.y) {
                    this.velY *= -0.8; // Bounce
                }
            }

            die() {
                this.isDead = true;
            }

            render(ctx, camera) {
                if (this.isDead) return;
                ctx.fillStyle = 'orange';
                ctx.beginPath();
                ctx.arc(this.x + this.width/2 - camera.x, this.y + this.height/2 - camera.y, this.width/2, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        window.onload = () => {
            new Game();
        };
    </script>
</body>
</html>